/**
 * Copyright 2014 General Dynamics Information Technology.
 */

define([
        'Bda/weather/obs/AddsParser',
        'Bda/weather/obs/WxxmParser',
        'Cesium/Core/Cartesian2',
        'Cesium/Core/Cartographic',
        'Cesium/Core/Color',
        'Cesium/Core/defined',
        'Cesium/Core/defineProperties',
        'Cesium/Core/DeveloperError',
        'Cesium/Core/getFilenameFromUri',
        'Cesium/Core/RuntimeError',
        'Cesium/Core/Ellipsoid',
        'Cesium/Core/Event',
        'Cesium/Core/loadXML',
        'Cesium/DataSources/BillboardGraphics',
        'Cesium/DataSources/ConstantProperty',
        'Cesium/DataSources/DataSource',
        'Cesium/DataSources/DataSourceClock',
        'Cesium/DataSources/Entity',
        'Cesium/DataSources/EntityCollection',
        'Cesium/DataSources/LabelGraphics',
        'Cesium/DataSources/PointGraphics',
        'Cesium/ThirdParty/when'
    ], function(
        AddsParser,
        WxxmParser,
        Cartesian2,
        Cartographic,
        Color,
        defined,
        defineProperties,
        DeveloperError,
        getFilenameFromUri,
        RuntimeError,
        Ellipsoid,
        Event,
        loadXML,
        BillboardGraphics,
        ConstantProperty,
        DataSource,
        DataSourceClock,
        Entity,
        EntityCollection,
        LabelGraphics,
        PointGraphics,
        when) {
    "use strict";


   /**
     * A {@link DataSource} which processes both WXXM and ADDS xml observation
     * data sources.
     * @alias ObsDataSource
     * @constructor
     */
    var ObsDataSource = function(bdaType) {
        //default point
        var defaultPoint = new Entity();
        var point = new PointGraphics();
		if (bdaType == 'airreport') {
           point.color = new ConstantProperty(Color.CYAN);
		} else if (bdaType == 'taf')
		{
           point.color = new ConstantProperty(Color.LIGHTGREEN);
		} else
		{
           point.color = new ConstantProperty(Color.BLUE);
		}
        point.pixelSize = new ConstantProperty(6);
		if (bdaType == 'airreport') {
           point.color = new ConstantProperty(Color.CYAN);
		} else if (bdaType == 'taf')
		{
           point.color = new ConstantProperty(Color.LIGHTGREEN);
		} else
		{
            point.outlineColor = new ConstantProperty(Color.BLUE);
		}
        point.outlineWidth = new ConstantProperty(1);
        point.show = new ConstantProperty(true);
        defaultPoint.point = point;

        //default label
        var defaultLabel = new Entity();
        var label = new LabelGraphics();
        label.scale = new ConstantProperty(.5);
        label.show = new ConstantProperty(false);
        label.pixelOffset = new ConstantProperty(new Cartesian2(0, 14));
        defaultLabel.label = label;

        var defaultWindBarb = new Entity();
        var windBarb = new BillboardGraphics();
        windBarb.scale = new ConstantProperty(.4);
        windBarb.show = new ConstantProperty(true);
        defaultWindBarb.billboard = windBarb;

        this._changed = new Event();
        this._error = new Event();
        this._isLoading = false;
        this._loading = new Event();
        this._entityCollection = new EntityCollection();
        this._clock = new DataSourceClock();

        this.defaultPoint = defaultPoint;
        this.defaultLabel = defaultLabel;
        this.defaultWindBarb = defaultWindBarb;

        this._name = undefined;
    };

    defineProperties(ObsDataSource.prototype, {
        /**
         * Gets the name of this data source.
         * @memberof ObsDataSource.prototype
         * @returns {string} The name.
         */
        name : {
            get : function() {
                return this._name;
            }
        },

        /**
         * Gets/sets the clock.
         * @memberof ObsDataSource.prototype
         * @return {Clock}
         */
        clock : {
            get : function() {
                return this._clock;
            },
            set : function(clock) {
                this._clock = clock;
            },
        },

        /**
         * Gets the EntityCollection generated by this data source.
         * @memberof ObsDataSource
         * @returns {EntityCollection} The collection of objects generated by this data source.
         */
        entities : {
            get : function() {
                return this._entityCollection;
            }
        },

        /**
         * Gets a value indicating if the data source is currently loading data.
         * @memberof ObsDataSource.prototype
         * @type {Boolean}
         */
        isLoading : {
            get : function() {
                return this._isLoading;
            }
        },

        /**
         * Gets an event that will be raised when the underlying data changes.
         * @memberof ObsDataSource.prototype
         * @type {Event}
         */
        changedEvent : {
            get : function() {
                return this._changed;
            }
        },

        /**
         * Gets an event that will be raised if an error is encountered during processing.
         * @memberof ObsDataSource.prototype
         * @type {Event}
         */
        errorEvent : {
            get : function() {
                return this._error;
            }
        },

        /**
         * Gets an event that will be raised when the data source either starts or stops loading.
         * @memberof ObsDataSource.prototype
         * @type {Event}
         */
        loadingEvent : {
            get : function() {
                return this._loading;
            }
        }
    });

    /**
     * Asynchronously loads the WXXM at the provided url, replacing any existing data.
     * @param {string} url The url to be processed.
     * @returns {Promise} a promise that will resolve when the WXXM is loaded.
     * @exception {DeveloperError} url is required.
     */
    ObsDataSource.prototype.loadUrl = function(url) {
        if (!defined(url)) {
            throw new DeveloperError('url is required.');
        }

        DataSource.setLoading(this, true);

        var dataSource = this;
        return when(loadXML(url), function(wxxm) {
            return dataSource.load(wxxm, url);
        }, function(error) {
            DataSource.setLoading(dataSource, false);
            dataSource._error.raiseEvent(dataSource, error);
            return when.reject(error);
        });
    };

    /**
     * Asynchronously loads the provided xml object, replacing any existing data.
     *
     * @param {Document} wxxm The object to be processed.
     * @param {string} [source] The base URI of any relative links in the  object.
     *
     * @returns {Promise} a promise that will resolve when the wxxm is loaded.
     *
     * @exception {DeveloperError} xml is required.
     * @exception {DeveloperError} Unsupported Wxxm object type.
     * @exception {RuntimeError} crs is null.
     * @exception {RuntimeError} crs.properties is undefined.
     * @exception {RuntimeError} Unknown crs name.
     * @exception {RuntimeError} Unable to resolve crs link.
     * @exception {RuntimeError} Unknown crs type.
     */
    ObsDataSource.prototype.load = function(xml, source) {
        var node = xml;
        if (!defined(xml)) {
            throw new DeveloperError('xml is required.');
        }

        this._name = undefined;
        if (defined(source)) {
            this._name = getFilenameFromUri(source);
        }

        var typeHandler;

        // Check for wxxm vs ADDS observation schema
        var wxxmFeature = xml.getElementsByTagName("FeatureCollection");
        if (wxxmFeature && wxxmFeature.length > 0) {
            typeHandler = WxxmParser.parseXmlData;
        }
        else {
            var response = xml.getElementsByTagName("response");
            if (response && response.length > 0) {
                typeHandler = AddsParser.parseXmlData;
            }
        }

        if (!defined(typeHandler)) {
            throw new DeveloperError('Unsupported METOC object type: ');
        }

        //Check for a Coordinate Reference System.
        var crsFunction = defaultCrsFunction;
        var crs = xml.crs;
        if (defined(crs)) {
            if (crs === null) {
                throw new RuntimeError('crs is null.');
            }
            if (!defined(crs.properties)) {
                throw new RuntimeError('crs.properties is undefined.');
            }

            var properties = crs.properties;
            if (crs.type === 'name') {
                crsFunction = ObsDataSource.crsNames[properties.name];
                if (!defined(crsFunction)) {
                    throw new RuntimeError('Unknown crs name: ' + properties.name);
                }
            } else if (crs.type === 'link') {
                var handler = ObsDataSource.crsLinkHrefs[properties.href];
                if (!defined(handler)) {
                    handler = ObsDataSource.crsLinkTypes[properties.type];
                }

                if (!defined(handler)) {
                    throw new RuntimeError('Unable to resolve crs link: ' + JSON.stringify(properties));
                }

                crsFunction = handler(properties);
            } else if (crs.type === 'EPSG') {
                crsFunction = ObsDataSource.crsNames['EPSG:' + properties.code];
                if (!defined(crsFunction)) {
                    throw new RuntimeError('Unknown crs EPSG code: ' + properties.code);
                }
            } else {
                throw new RuntimeError('Unknown crs type: ' + crs.type);
            }
        }

        var dataSource = this;
        return when(crsFunction, function(crsFunction) {
            typeHandler(dataSource, node, crsFunction);
            dataSource._changed.raiseEvent(dataSource);
            setLoading(dataSource, false);
        }, function(error) {
            setLoading(dataSource, false);
            dataSource._error.raiseEvent(dataSource, error);
            return when.reject(error);
        });
    };

    /**
     * Converts the degree coordinates to cartesian3 coordinates.
     * @param {Array} coordinates  The array of longitude and latitude coordinates
     * @returns {Cartesian3}
     */
    function defaultCrsFunction(coordinates) {
        var cartographic = Cartographic.fromDegrees(coordinates[0], coordinates[1], coordinates[2]);
        return Ellipsoid.WGS84.cartographicToCartesian(cartographic);
    }

    /**
     * An object that maps the name of a crs to a callback function which takes a gml coordinate
     * and transforms it into a WGS84 Earth-fixed Cartesian.  Older versions of gml which
     * supported the EPSG type can be added to this list as well, by specifying the complete EPSG name,
     * for example 'EPSG:4326'.
     * @memberof ObsDataSource
     * @type {Object}
     */
    ObsDataSource.crsNames = {
        'urn:ogc:def:crs:OGC:1.3:CRS84' : defaultCrsFunction,
        'EPSG:4326' : defaultCrsFunction
    };
//      <gml:Point                  srsName="urn:ogc:crs:EPSG:4979" srsDimension="3" gml:id="id4">      // from METAR example
//      <gml:Point srsDimension="2" srsName="http://www.opengis.net/gml/srs/epsg.xml#4326">             // from geoserver GML request

    /**
     * An object that maps the href property of a crs link to a callback function
     * which takes the crs properties object and returns a Promise that resolves
     * to a function that takes a gml coordinate and transforms it into a WGS84 Earth-fixed Cartesian.
     * Items in this object take precedence over those defined in <code>crsLinkHrefs</code>, assuming
     * the link has a type specified.
     * @memberof ObsDataSource
     * @type {Object}
     */
    ObsDataSource.crsLinkHrefs = {};

    /**
     * An object that maps the type property of a crs link to a callback function
     * which takes the crs properties object and returns a Promise that resolves
     * to a function that takes a gml coordinate and transforms it into a WGS84 Earth-fixed Cartesian.
     * Items in <code>crsLinkHrefs</code> take precedence over this object.
     * @memberof ObsDataSource
     * @type {Object}
     */
    ObsDataSource.crsLinkTypes = {};

    return ObsDataSource;
});
