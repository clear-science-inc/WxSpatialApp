/**
 * Copyright 2014 General Dynamics Information Technology.
 */

define([
        'Bda/util/ObsProperty',
        'Bda/util/Util',
        'Cesium/Core/createGuid',
        'Cesium/Core/Cartesian2',
        'Cesium/Core/JulianDate',
        'Cesium/Core/TimeInterval',
        'Cesium/Core/TimeIntervalCollection',
        'Cesium/Core/Cartographic',
        'Cesium/Core/Color',
        'Cesium/Core/defaultValue',
        'Cesium/Core/defined',
        'Cesium/Core/defineProperties',
        'Cesium/Core/DeveloperError',
        'Cesium/Core/getFilenameFromUri',
        'Cesium/Core/RuntimeError',
        'Cesium/Core/Ellipsoid',
        'Cesium/Core/Event',
        'Cesium/Core/loadJson',
        'Cesium/Core/loadXML',
        'Cesium/Core/Math',
        'Cesium/DataSources/ColorMaterialProperty',
        'Cesium/DataSources/DataSourceClock',
        'Cesium/DataSources/ConstantProperty',
        'Cesium/DataSources/BillboardGraphics',
        'Cesium/DataSources/Entity',
        'Cesium/DataSources/PolylineGraphics',
        'Cesium/DataSources/LabelGraphics',
        'Cesium/DataSources/EntityCollection',
        'Cesium/ThirdParty/when'
    ], function(
        ObsProperty,
        Util,
        createGuid,
        Cartesian2,
        JulianDate,
        TimeInterval,
        TimeIntervalCollection,
        Cartographic,
        Color,
        defaultValue,
        defined,
        defineProperties,
        DeveloperError,
        getFilenameFromUri,
        RuntimeError,
        Ellipsoid,
        Event,
        loadJson,
        loadXML,
        CesiumMath,
        ColorMaterialProperty,
        DataSourceClock,
        ConstantProperty,
        BillboardGraphics,
        Entity,
        PolylineGraphics,
        LabelGraphics,
        EntityCollection,
        when) {
    "use strict";
    
    /**
     * @constructor
     */
    var RouteDataSource = function() {
        
        // Default Polyline
        var defaultPolyline = new Entity();
        var polyline = new PolylineGraphics();
        var defaultMaterial = new ColorMaterialProperty(Color.CYAN);
        polyline.material = defaultMaterial;
        polyline.width = new ConstantProperty(2);
        polyline.show = new ConstantProperty(true);
        defaultPolyline.polyline = polyline;
                
        //default label
        var defaultLabel = new Entity();
        var label = new LabelGraphics();
        label.scale = new ConstantProperty(.5);
        label.show = new ConstantProperty(false);
        label.pixelOffset = new ConstantProperty(new Cartesian2(0, 14));
        defaultLabel.label = label;
        
        // Default Airplane marker
        var defaultAirplaneObj = new Entity();
        var airplane = new BillboardGraphics();
        airplane.scale = new ConstantProperty(1);
        airplane.show = new ConstantProperty(true);
        airplane.image = new ConstantProperty('resources/icons/airplane.png');
        defaultAirplaneObj.billboard = airplane;
        
        this._changed = new Event();
        this._error = new Event();
        this._isLoading = false;
        this._loading = new Event();
        this._entityCollection = new EntityCollection();
        this._clock = new DataSourceClock();

        this.defaultPolyline = defaultPolyline;
        this.defaultLabel = defaultLabel;
        this.defaultAirplaneObj = defaultAirplaneObj;
        
        this.defaultMaterial = defaultMaterial;
        this.goodMaterial = new ColorMaterialProperty(Color.GREEN);
        this.marginalMaterial = new ColorMaterialProperty(Color.YELLOW);
        this.severeMaterial = new ColorMaterialProperty(Color.RED);
    };
    
    function setLoading(dataSource, isLoading) {
       if (dataSource._isLoading !== isLoading) {
           dataSource._isLoading = isLoading;
           dataSource._loading.raiseEvent(dataSource, isLoading);
       }
    }
    
    defineProperties(RouteDataSource.prototype, {
        /**
         * Gets the name of this data source.
         * @memberof RouteDataSource.prototype
         * @returns {string} The name.
         */
        name : {
            get : function() {
                return this._name;
            }
        },
        
        /**
         * Gets/sets the clock. 
         * @memberof RouteDataSource.prototype
         * @return {Clock}
         */
        clock : {
            get : function() {
                this._clock;
            },
            set : function(clock) {
                this._clock = clock;
            },
        },
   
        /**
         * Gets the EntityCollection generated by this data source.
         * @memberof RouteDataSource.prototype
         * @returns {EntityCollection} The collection of objects generated by this data source.
         */
        entities : {
            get : function() {
                return this._entityCollection;
            }
        },
        
        /**
         * Gets a value indicating if the data source is currently loading data.
         * @memberof RouteDataSource.prototype
         * @type {Boolean}
         */
        isLoading : {
            get : function() {
                return this._isLoading;
            }
        },
        
        /**
         * Gets an event that will be raised when the underlying data changes.
         * @memberof RouteDataSource.prototype
         * @type {Event}
         */
        changedEvent : {
            get : function() {
                return this._changed;
            }
        },

        /**
         * Gets an event that will be raised if an error is encountered during processing.
         * @memberof RouteDataSource.prototype
         * @type {Event}
         */
        errorEvent : {
            get : function() {
                return this._error;
            }
        },
        
        /**
         * Gets an event that will be raised when the data source either starts or stops loading.
         * @memberof RouteDataSource.prototype
         * @type {Event}
         */
        loadingEvent : {
            get : function() {
                return this._loading;
            }
        }
    });
    
    /**
     * Creates the dynamic object.
     * @param {EntityCollection} entityCollection
     */
    function createObject(entityCollection) {
        var  id = createGuid();
        var entity = entityCollection.getOrCreateEntity(id);
        entity.envProperties = {};
        entity.bdaType = "FLIGHT_PATH";
        entity.name = 'undefined';
        
        return entity;
    }
    
    /**
     * Parses the routeData array of json objects into RouteDataSource.
     * @param {{flightpath:Array, name:string}[]} routeData 
     * @param {RouteDataSource} dataSource
     */
    function parseRouteData(routeData, dataSource) {
        
        for (var i=0; i<routeData.length; i++) {
            var stopTimeMs = new Date(routeData[i].flightpath[routeData[i].flightpath.length -1].time).getTime() + 5000;
            
            // Make airplane at start of route
            var firstStart = new Date(routeData[i].flightpath[0].time);
            var firstEnd = new Date(firstStart.getTime() + 10);
            makeAirplaneObject(dataSource, routeData[i].name, routeData[i].flightpath[0], firstStart, firstEnd);
            
            for (var j=1; j<routeData[i].flightpath.length; j++) {
                // Create Polyline, displays till end of route
                var polylineObject = createObject(dataSource._entityCollection);
                polylineObject.name = routeData[i].name;
                polylineObject.merge(dataSource.defaultPolyline); 
                var point1 = routeData[i].flightpath[j-1];
                var point2 = routeData[i].flightpath[j];
                polylineObject.polyline.positions = new ConstantProperty(Ellipsoid.WGS84.cartographicArrayToCartesianArray([
                   Cartographic.fromDegrees(point1.lon, point1.lat, point1.alt),
                   Cartographic.fromDegrees(point2.lon, point2.lat, point2.alt)]));
                   
                var startTime = (j>1) ? (new Date(routeData[i].flightpath[j-1].time)) : firstEnd;
                var timeInterval = new TimeInterval({ start: JulianDate.fromDate(startTime), stop: JulianDate.fromDate(new Date(stopTimeMs))});
                var timeIntervalCollection = new TimeIntervalCollection();
                timeIntervalCollection.addInterval(timeInterval);
                polylineObject.availability = timeIntervalCollection; 
               
                // Create Airplane object, display for just this interval
                var endPoint = routeData[i].flightpath[j];
                var stopTime = (j < (routeData[i].flightpath.length - 1)) ? (new Date(routeData[i].flightpath[j].time)) : (new Date(startTime.getTime() + 5000));
                makeAirplaneObject(dataSource, routeData[i].name, endPoint, startTime, stopTime);
            }                       
        }
        
        /**
         * Makes an airplane dynamic object. 
         * @param {RouteDataSource} dataSource
         * @param {string} routeName
         * @param {{lat:number, lon:number, alt:number}} point
         * @param {Date} startTime
         * @param {Date} endTime
         */
        function makeAirplaneObject(dataSource, routeName, point, startTime, stopTime) {
            var airplaneObject = createObject(dataSource._entityCollection);
            airplaneObject.name = routeName;
            airplaneObject.merge(dataSource.defaultLabel);
            airplaneObject.merge(dataSource.defaultAirplaneObj);
            
            // Make label
            airplaneObject._label.text = new ConstantProperty(routeName);
             
            airplaneObject.position = new ConstantProperty(makePosition(point));
                                    
            // Assign time interval to airplane object
            var timeInterval = new TimeInterval({start: JulianDate.fromDate(new Date(startTime)), stop: JulianDate.fromDate(stopTime)});
            var timeIntervalCollection = new TimeIntervalCollection();
            timeIntervalCollection.addInterval(timeInterval);
            airplaneObject.availability = timeIntervalCollection;                            
        }
         
        /**
         * Makes a cartesian object out of flightpath point.
         * @param {{lat:number, lon:number, alt:number}} point
         * @return {Cartesian3}
         */       
        function makePosition(point) {
            var cartographic = Cartographic.fromDegrees(point.lon, point.lat, point.alt);
            return Ellipsoid.WGS84.cartographicToCartesian(cartographic);
        }       
    }
    
    /**
     * Requests the environment data that needs to be associated with the 
     * RouteDataSource.
     * @param {RouteDataSource} dataSource 
     * @param {function} whenFunction  function to call when request completed
     */
    function getEnvironmentData(dataSource, whenFunction) {
        var aoi = makeAoi(dataSource);
        when(requestGrids(aoi, dataSource), 
            function(dataSource) {
                try {
                var routeObjects = dataSource.entities.values;
                routeObjects.sort(compareRouteObjects);
                addEnvironmentData(dataSource);
                whenFunction();
                } catch (e) {
                    console.error(e.stack);
                }
            },
            function(error) {
                dataSource._error.raiseEvent(dataSource, error);
                return when.reject(error);
        });
        
        /**
         * Makes an area of interest based on all the route points in the
         * RouteDataSource. 
         * @param {RouteDataSource} dataSource 
         * @return {{north:number, south:number, east:number, west:number}}
         */
        function makeAoi(dataSource) {
            var north = -90;
            var south = 90;
            var east = -180;
            var west = 180;
            
            var routes = dataSource.entities.values;
            for (var i=0; i<routes.length; i++) {
                if (defined(routes[i].positions)) {
                    var positions = routes[i].positions.getValue();
                    var cartos = Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);
                    for (var j=0; j<cartos.length; j++) {
                        // TODO: check for crossing intl date line (west > east)
                        north = Math.max(north, CesiumMath.toDegrees(cartos[j].latitude));
                        south = Math.min(south, CesiumMath.toDegrees(cartos[j].latitude));
                        east  = Math.max(east, CesiumMath.toDegrees(cartos[j].longitude));
                        west  = Math.min(west, CesiumMath.toDegrees(cartos[j].longitude));
                    }
                }
            }
            
            return { north: north, west: west, south: south, east: east };
        }
        
        /**
         * Requests the gridded data. 
         * @param {{north:number, south:number, east:number, west:number}} aoi
         * @param {RouteDataSource} dataSource 
         * @return {RouteDataSource}
         */
        function requestGrids(aoi, dataSource) {
            // TODO: where is our data coming from?
            //       probabably need multiple ISBL levels based on altitude
            return dataSource;
        }    
        
        /**
         * Associates the environment with each data point in the RouteDataSource. 
         * @param {RouteDataSource} dataSource 
         */
        function addEnvironmentData(dataSource) {
            var visCache = {};
            var tccCache = {};
            var wsCache = {};
    
            var routes = dataSource.entities.values;
            for (var i=0; i<routes.length; i++) {
                var position;
                if (defined(routes[i].polyline) && defined(routes[i].polyline.positions)) {                    
                    position = routes[i].polyline.positions.getValue()[1]; // take stop point                   
                }
                else if (defined(routes[i].position)) { // airplane marker
                    position = routes[i].position.getValue();
                }
                
                if (defined(position)) {
                    var cartographicPosition = Ellipsoid.WGS84.cartesianToCartographic(position);
                    var lat = CesiumMath.toDegrees(cartographicPosition.latitude);
                    var lon = CesiumMath.toDegrees(cartographicPosition.longitude);
                    var alt = cartographicPosition.height;
                    var time = routes[i].availability.get(0).stop;
                    
                    routes[i].envProperties['horizontalVisibility'] = lookupVisibilityProperty(lat, lon, alt, time);
                    routes[i].envProperties['windSpeed'] = lookupWindSpeedProperty(lat, lon, alt, time);
                    routes[i].envProperties['totalCloudCover'] = lookupCloudCoverProperty(lat, lon, alt, time);
                }
            }
        
            function lookupVisibilityProperty(latitude, longitude, altitude, time) {
                var key = makeKey(latitude, longitude, altitude, time);
                var visibility = visCache[key];
                if (!defined(visibility)) {
                    // TODO: get actual data and units
                    visibility = Math.random()*10;
                    visCache[key] = visibility;
                }
                return new ObsProperty('mi', visibility.toString());
            }
            
            function lookupWindSpeedProperty(latitude, longitude, altitude, time) {
                var key = makeKey(latitude, longitude, altitude, time);
                var windSpeed = wsCache[key];
                if (!defined(windSpeed)) {
                    // TODO: 
                    windSpeed = Math.random()*40;
                    wsCache[key] = windSpeed;
                }
                return new ObsProperty('mph', windSpeed.toString());
            }
            
            function lookupCloudCoverProperty(latitude, longitude, altitude, time) {
                var key = makeKey(latitude, longitude, altitude, time);
                var cloudCover = tccCache[key];
                if (!defined(cloudCover)) {
                    // TODO: 
                    var cloudCover = Math.floor(Math.random()*100) + 1;
                    tccCache[key] = cloudCover;
                }
                return new ObsProperty('%', cloudCover.toString());
            }
            
            function makeKey(latitude, longitude, altitude, time) {
                //return latitude+"-"+longitude+"-"+altitude+"-"+time;
                var checksum = Util.checksum(latitude+"-"+longitude+"-"+altitude+"-"+time);
                return checksum;

            }            
        }
    }
    
    /**
     * Comparator for route objects. Sorts by name and then start
     * time within the named route.
     * @param {Entity} route1
     * @param {Entity} route2
     * @return {number}
     */
    function compareRouteObjects(route1, route2) {
        if (route1.name < route2.name) {
            return -1;
        }
        else if (route1.name > route2.name) {
            return 1;
        }
        else {
            var start1 = route1.availability.get(0).start;
            var start2 = route2.availability.get(0).start;
            var compareValue = JulianDate.compare(start1, start2);
            
            if (compareValue == 0) {
                var stop1 = route1.availability.get(0).stop;
                var stop2 = route2.availability.get(0).stop;
                compareValue = JulianDate.compare(stop1, stop2);
            }                 
            return compareValue;
        }
    }
    
    /**
     * Asynchronously loads the Routes at the provided url, replacing any existing data.
     * @param {string} url The url to be processed.
     * @param {function} whenFunction  The function to call when promise resolved
     * @returns {Promise} a promise that will resolve when the WXXM is loaded.
     * @exception {DeveloperError} url is required.
     */
    RouteDataSource.prototype.loadUrl = function(url, whenFunction) {
        if (!defined(url)) {
            throw new DeveloperError('url is required.');
        }

        setLoading(this, true);
        
        var dataSource = this;
        
        return when(loadJson(url), function(json) {
            dataSource.load(json, url);
//            whenFunction();
            getEnvironmentData(dataSource, whenFunction);
            setLoading(dataSource, false);
        }, function(error) {
            setLoading(dataSource, false);
            dataSource._error.raiseEvent(dataSource, error);
            return when.reject(error);
        });        
    };
    
    /**
     * Loads the json array into RouteDataSource.
     * @param {{flightpath:Array, name:string}[]} json 
     */
    RouteDataSource.prototype.load = function(json) {
        parseRouteData(json, this);
    };
        
    return RouteDataSource;
});

